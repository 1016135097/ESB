package com.perkinelmer.service.renji;

import org.slf4j.Logger;
import com.streambase.sb.*;
import com.streambase.sb.operator.*;
import com.streambase.sb.Tuple;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.HttpURLConnection;
import java.nio.charset.StandardCharsets;

/**
 * Generated by JDT StreamBase Client Templates (Version: 7.6.7.1702081658).
 * 
 * sbd -f sbd.sbconf RenJiHospitalJava.sbapp
 * 
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * <p>
 * If there is any state that the operator instance needs to maintain beyond the
 * lifetime of the instance, the setSessionState/getSessionState methods can
 * be used.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class Renji extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1516680464059L;
	private Logger logger;
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 1;
	private int nextOutputPort = 0;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	

	/**
	 * The constructor is called when the Operator instance is created, but before the Operator 
	 * is connected to the StreamBase application. We recommended that you set the initial input
	 * port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	 * The default is 1 input port, 1 output port. The constructor may also set default values for 
	 * operator parameters. These values will be displayed in StreamBase Studio when a new instance
	 * of this operator is  dragged to the canvas, and serve as the default values for omitted
	 * optional parameters.
	 */
	public Renji() {
		super();
		logger = getLogger();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(this.getClass().getSimpleName());
		setShortDisplayName(this.getClass().getSimpleName());
	}

	/**
	 * The typecheck method is called after the Operator instance is connected in the StreamBase
	 * application, allowing the Operator to validate its properties. The Operator class may 
	 * change the number of input or output ports by calling the requireInputPortCount(portCount)
	 * method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	 * is passed a different number of ports than the Operator currently has, a PortMismatchException
	 * (subtype of TypecheckException) is thrown.
	 */
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);

		// TODO Ensure that all properties have valid values, and typecheck the input schemas here

		// you must specify a setOutputSchema for each port, so that StreamBase Studio
		// knows how many output ports to draw for the output ports. If you do not
		// use setOutputSchema for each port, the Java Operator on the StreamBase Studio
		// canvas will not display the correct number of output ports.
		for (int i = 0; i < outputPorts; ++i) {
			// TODO this example sets every output port Schema the same as the first input port; change this as needed
			setOutputSchema(i, getInputSchema(0));
		}

	}

	/**
	 * This method will be called by the StreamBase server for each Tuple given
	 * to the Operator to process. This is the only time an operator should 
	 * enqueue output Tuples.
	 * @param inputPort the input port that the tuple is from (ports are zero based)
	 * @param tuple the tuple from the given input port
	 * @throws StreamBaseException Terminates the application.
	 */
	public void processTuple(int inputPort, Tuple tuple)
			throws StreamBaseException {
		// TODO only the first input port is processed; see the template code for typecheck()
		if (inputPort > 0) {
			return;
		}

		// create a new output tuple from the Schema at the port we are about to send to
		Tuple out = outputSchemas[inputPort].createTuple();

		// TODO this template just copies each field value from input port 0 (the first input port)
		for (int i = 0; i < out.getSchema().getFieldCount(); ++i) {
			// note: best performance is achieved retrieving values through Tuple#getField(Schema.Field)
			out.setField(i, tuple.getField(i));
		}

		URL url;
		HttpURLConnection connection;
		String status = "Succ";
		Date startTime = new Date();
		try {
			String urlReplaceFrom = tuple.getString("UrlReplaceFrom");
			String urlReplaceFrom1 = tuple.getString("UrlReplaceFrom1");
			//这里替换的地址需要从Services表中拿对应真实路径
			String urlReplaceTo = tuple.getString("UrlReplaceTo");
			String urlString = tuple.getString("RequestUrl").replace(urlReplaceFrom, urlReplaceTo).replace(urlReplaceFrom1, urlReplaceTo); 
			String content = tuple.getString("RequestData");
			String MessageType = tuple.getString("MessageType");
			if(MessageType.equals("GET")){
				List<String> params1=new ArrayList<String>();
				String[] params = content.split("&");
				for(int i=0;i<params.length;i++){
					params1.add(params[i].replace(",", "="));
				}
				if(params1.size()==1||params1.get(0).equalsIgnoreCase("wsdl")){
					content="WSDL";
				}else{
					content = String.join("&", params1);
				}
				url = new URL(urlString+"?"+content);
				connection = (HttpURLConnection) url.openConnection();
				connection.setRequestMethod("GET");
				connection.setRequestProperty("Content-Type", "text/xml; charset=utf-8");
				connection.setDoInput(true); 
			    connection.setDoOutput(true);
			}else{
				url = new URL(urlString);
				connection = (HttpURLConnection) url.openConnection();
				connection.setRequestMethod("POST");
				if(MessageType.equals("POST")){
					connection.setRequestProperty("Content-Type","application/x-www-form-urlencoded");
				}else if(MessageType.equals("SOAP1.1")){
					String soapAction = tuple.getString("SoapAction");
					connection.setRequestProperty("Content-Type", "text/xml; charset=utf-8");
					connection.setRequestProperty("SOAPAction", soapAction);
				}else if(MessageType.equals("SOAP1.2")){
					connection.setRequestProperty("Content-Type", "application/soap+xml; charset=utf-8");
				}else{
					logger.error("没有此webservice协议（"+MessageType+"）！");
				}
				connection.setDoInput(true);
			    connection.setDoOutput(true);
			    connection.setUseCaches(false);
				connection.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));
				System.setProperty("http.keepAlive","false");
			}
			InputStream inputStream = connection.getInputStream();
			long interval = new Date().getTime()-startTime.getTime();
			out.setInt("WSInterval",(int)interval);
		    BufferedReader rd = new BufferedReader(new InputStreamReader(inputStream,"UTF-8"));
		    StringBuilder response = new StringBuilder(); // or StringBuffer if Java version 5+
		    String line;
		    while ((line = rd.readLine()) != null) {
		      response.append(line);
		      response.append('\r');
		    }
		    rd.close();
		    String res = response.toString();
			out.setString("RequestData", content);
			out.setString("ResponseData", res);

		} catch (Exception e) {
			logger.error(e.toString());
 			status = "Fail";
 			long interval = new Date().getTime()-startTime.getTime();
			out.setInt("WSInterval", (int)interval);
 			out.setString("ResponseData", e.getMessage() + ": " + e.getStackTrace());
		}
		out.setString("Status", status);
		// nextOutputPort is used to send tuples by round-robin on every output port by this template.
		sendOutput(nextOutputPort, out);
		nextOutputPort = (nextOutputPort + 1) % outputPorts;
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase application
	 * is started. Note that your Operator class is not required to define the init method,
	 * unless (for example) you need to perform initialization of a resource such as a JDBC
	 * pool, if your operator is making JDBC calls. StreamBase Studio does not call this
	 * during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		// for best performance, consider caching input or output Schema.Field objects for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
	}

	/**
	 *  The shutdown method is called when the StreamBase server is in the process of shutting down.
	 */
	public void shutdown() {

	}
}
